# -*- coding: utf-8 -*-
"""FPfinal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wsMgxZHtTctHIicS45LK4qtKsYQjO1Tw
"""

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

import csv

#name of the node, a count
#nodelink used to link similar items
#parent vaiable used to refer to the parent of the node in the tree
#node contains an empty dictionary for the children in the node
class Node:
    def __init__(self, name_val, occurences, parent_node):
        self.name = name_val
        self.count = occurences
        self.link = None
        self.parent = parent_node      
        self.children = {} 
    
    def increment(self, occurences):
        self.count += occurences
      
    def disp(self, ind=1):
        print ('  '*ind, self.name, ' ', self.count)
        for child in self.children.values():
            child.disp(ind+1)

def createTree(data_set, min_sup=1): 
    node_table = {}
    
    for transaction in data_set:
        for item in transaction:
            node_table[item] = node_table.get(item, 0) + data_set[transaction]
    for k in list(node_table): 
        if node_table[k] < min_sup: 
            del(node_table[k])
    freq_item_set = set(node_table.keys())
   
    if len(freq_item_set) == 0: return None, None  
    for k in node_table:
        node_table[k] = [node_table[k], None]  
   
    ret_tree = Node('Null Set', 1, None) 
    for tran_set, count in data_set.items():  
        localD = {}
        for item in tran_set:  
            if item in freq_item_set:
                localD[item] = node_table[item][0]
        if len(localD) > 0:
            ordered_items = [v[0] for v in sorted(localD.items(), key=lambda p: p[1], reverse=True)]
            updateTree(ordered_items, ret_tree, node_table, count)
    return ret_tree, node_table 
  
def updateTree(items, in_tree, node_table, count):
    if items[0] in in_tree.children:
        in_tree.children[items[0]].increment(count) 
    else:   
        in_tree.children[items[0]] = Node(items[0], count, in_tree)
        if node_table[items[0]][1] == None:  
            node_table[items[0]][1] = in_tree.children[items[0]]
        else:
            updateHeader(node_table[items[0]][1], in_tree.children[items[0]])
    if len(items) > 1:
        updateTree(items[1::], in_tree.children[items[0]], node_table, count)

def updateHeader(current, target):   
    while (current.link != None):    
        current = current.link
    current.link = target

def load_sample():
    sample = [['a', 'b', 'c', 'd'],
               ['a', 'b'],
               ['b','c','d'],
               ['a', 'c', 'd', 'e'],
               ['a', 'd', 'e'],
               ['a', 'b','c'],
               ['a'],
               ['a','b','c'],
               ['a','b','d'],
               ['b','c','e']]
    return sample
  
def createInitSet(data_set):
    ret_dict = {}
    for transaction in data_set:
      if frozenset(transaction) in ret_dict:
        ret_dict[frozenset(transaction)] += 1
      else:  
        ret_dict[frozenset(transaction)] = 1
    return ret_dict

min_support = 0.01
min_confidence = 0.5
transactions = list()
with open('groceries.csv',newline = '') as csvfile:
    reader = csv.reader(csvfile)
    for row in reader:
        transactions.append(list(row))
        
#sample = load_sample()
init_set = createInitSet(transactions)
FPtree, node_table = createTree(init_set, min_support*len(transactions))
#FPtree.disp()

def ascendTree(leaf_node, prefix_path): 
    if leaf_node.parent != None:
        prefix_path.append(leaf_node.name)
        ascendTree(leaf_node.parent, prefix_path)
        
def findPrefixPath(base_path, Node): 
    cond_paths = {}
    while Node != None:
        prefix_path = []
        ascendTree(Node, prefix_path)
        if len(prefix_path) > 1: 
            cond_paths[frozenset(prefix_path[1:])] = Node.count
        Node = Node.link
    return cond_paths
  
def mineTree(in_tree, node_table, min_sup, preFix, freq_item_list):
  bigL = [v[0] for v in sorted(node_table.items(), key=lambda p: p[1][0])]
  for base_path in bigL:
    new_freq_set = preFix.copy()
    new_freq_set.add(base_path)
    freq_item_list.append(new_freq_set)
    cond_patt_bases = findPrefixPath(base_path, node_table[base_path][1])
    cond_tree, head = createTree(cond_patt_bases, min_sup)
    if head != None:
      mineTree(cond_tree, head, min_sup, new_freq_set, freq_item_list)

freq_items = []
mineTree(FPtree, node_table, min_support*len(transactions), set([]), freq_items)
freq_items